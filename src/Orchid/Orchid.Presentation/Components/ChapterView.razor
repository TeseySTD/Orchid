@using Orchid.Core.Models.ValueObjects
@inject IJSRuntime Js
@implements IAsyncDisposable

<style>
    @((MarkupString)_bookCss)
</style>

<div class="chapter-viewport" @ref="_chapterViewportElement">
    <div class="chapter-content" id="@_elementId" @ref="_chapterElement">
        @if (!string.IsNullOrEmpty(_currentChapter?.Html))
        {
            @((MarkupString)_currentChapter.Html)
        }
    </div>
</div>

@code {
    [Parameter] [EditorRequired] public required Chapter Chapter { get; set; }
    [Parameter] public IEnumerable<CssFile> BookCss { get; set; } = [];
    [Parameter] public EventCallback OnNewChapterProcessed { get; set; }
    [Parameter] public EventCallback<int> OnPagesCountChanged { get; set; }

    private ElementReference _chapterViewportElement;
    private ElementReference _chapterElement;
    private Chapter? _currentChapter = null;
    private string _bookCss = string.Empty;
    private string _elementId = $"chapter-{Guid.NewGuid()}";
    private int _totalPages = 1;
    private int _currentPage = 0;
    private bool _newChapterRecalculating = false;
    private bool _neededPageRecalculation = false;
    private DotNetObjectReference<ChapterView>? _dotNetRef;

    protected override async Task OnParametersSetAsync()
    {
        var isNewChapter = _currentChapter != Chapter;
        _bookCss = string.Join("\n", BookCss.Select(d => d.Content));
        _currentChapter = Chapter;

        if (isNewChapter)
        {
            _currentPage = 0;
            _newChapterRecalculating = true;
            await CalculatePagesWithRenderAsync();
        }
    }

    private async Task CalculatePagesAsync()
    {
        _totalPages = await Js.InvokeAsync<int>("orchidReader.getPageCount", _chapterElement);
    }

    private async Task CalculatePagesWithRenderAsync()
    {
        _neededPageRecalculation = true;
        await InvokeAsync(StateHasChanged);
    }

    public async Task GoToPageAsync(int pageIndex)
    {
        if (pageIndex >= 0 && pageIndex < _totalPages)
        {
            _currentPage = pageIndex;
            await Js.InvokeVoidAsync("orchidReader.scrollToPage", _chapterElement, _currentPage);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            await Js.InvokeVoidAsync("utils.resizeObserve", _chapterViewportElement, _dotNetRef);
        }

        if (_neededPageRecalculation)
        {
            _neededPageRecalculation = false;
            await CalculatePagesAsync();
            await OnPagesCountChanged.InvokeAsync(_totalPages);
            if (_newChapterRecalculating)
            {
                _newChapterRecalculating = false;
                await OnNewChapterProcessed.InvokeAsync();
            }
        }
    }

    [JSInvokable]
    public async Task OnResize()
    {
        if (!_newChapterRecalculating) // Lock for new chapter case
            await CalculatePagesWithRenderAsync();
    }

    public async ValueTask DisposeAsync()
    {
        if (_dotNetRef != null)
        {
            try
            {
                await Js.InvokeVoidAsync("utils.resizeUnobserve", _chapterViewportElement);
            }
            catch (JSDisconnectedException)
            {
                // Ignored: The circuit/browser is already gone
            }
            finally
            {
                _dotNetRef.Dispose();
            }
        }
    }

}



