@using Orchid.Core.Models.ValueObjects
@inject IJSRuntime Js
@implements IAsyncDisposable

<style>
    @((MarkupString)_bookCss)
</style>

<div class="chapter-viewport" @ref="_chapterViewportElement">
    <div class="chapter-content"
         id="@_elementId"
         @ref="ChapterElement"
         style="@VisibilityStyle">
        @if (!string.IsNullOrEmpty(_currentChapter?.Html))
        {
            @((MarkupString)_currentChapter.Html)
        }
    </div>
</div>

@code {
    [Parameter] [EditorRequired] public required Chapter Chapter { get; set; }
    [Parameter] public IEnumerable<CssFile> BookCss { get; set; } = [];
    [Parameter] public EventCallback OnNewChapterProcessed { get; set; }
    [Parameter] public EventCallback<int> OnPagesCountChanged { get; set; }
    [Parameter] public EventCallback OnPageContextChangeCallback { get; set; }
    [Parameter] public EventCallback OnPageContextChangeEndCallback { get; set; }

    public ElementReference ChapterElement;
    private ElementReference _chapterViewportElement;
    private Chapter? _currentChapter = null;
    private string _bookCss = string.Empty;
    private string _elementId = $"chapter-{Guid.NewGuid()}";
    private int _totalPages = 1;
    private int _currentPage = 0;
    private bool _newChapterRecalculating = false;
    private bool _neededPageRecalculation = false;
    private bool _isReady = false; // Controls visibility to prevent flickering before scroll is set
    private string VisibilityStyle => _isReady ? "opacity: 1;" : "opacity: 0;";
    private DotNetObjectReference<ChapterView>? _dotNetRef;

    protected override async Task OnParametersSetAsync()
    {
        var isNewChapter = _currentChapter != Chapter;
        _bookCss = string.Join("\n", BookCss.Select(d => d.Content));
        _currentChapter = Chapter;

        if (isNewChapter)
        {
            _isReady = false;
            _currentPage = 0;
            _newChapterRecalculating = true;
            await CalculatePagesWithRenderAsync();
        }
    }

    private async Task CalculatePagesAsync()
    {
        _totalPages = await Js.InvokeAsync<int>("orchidReader.getPageCount", ChapterElement);
    }

    private async Task CalculatePagesWithRenderAsync()
    {
        _neededPageRecalculation = true;
        await InvokeAsync(StateHasChanged);
    }

    public async Task GoToPageAsync(int pageIndex)
    {
        if (pageIndex >= 0 && pageIndex < _totalPages)
        {
            _currentPage = pageIndex;
            await Js.InvokeVoidAsync("orchidReader.scrollToPage", ChapterElement, _currentPage);
            _isReady = true;
        }
    }

    public async Task<int> GoToPageLocatorAsync(string locator)
    {
        try
        {
            var pageIndex = await Js.InvokeAsync<int>("orchidReader.scrollToLocator", ChapterElement, locator);

            _currentPage = pageIndex;
            _isReady = true;
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Cannot scroll to locator: {ex.Message}");
        }

        return _currentPage;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _dotNetRef = DotNetObjectReference.Create(this);
            await Js.InvokeVoidAsync("utils.pageContextObserve", _chapterViewportElement, _dotNetRef);
        }

        if (_neededPageRecalculation)
        {
            _neededPageRecalculation = false;
            await CalculatePagesAsync();
            await OnPagesCountChanged.InvokeAsync(_totalPages);
            if (_newChapterRecalculating)
            {
                _newChapterRecalculating = false;
                await OnNewChapterProcessed.InvokeAsync();
            }
        }
    }

    [JSInvokable]
    public async Task OnPageContextChange()
    {
        if (!_newChapterRecalculating) // Lock for new chapter case
            await CalculatePagesWithRenderAsync();
        await OnPageContextChangeCallback.InvokeAsync();
    }

    [JSInvokable]
    public async Task OnPageContextChangeEnd()
    {
        await OnPageContextChangeEndCallback.InvokeAsync();
    }

    public async ValueTask DisposeAsync()
    {
        if (_dotNetRef != null)
        {
            try
            {
                await Js.InvokeVoidAsync("utils.pageContextUnobserve", _chapterViewportElement);
            }
            catch (JSDisconnectedException)
            {
                // Ignored: The circuit/browser is already gone
            }
            finally
            {
                _dotNetRef.Dispose();
            }
        }
    }

}



